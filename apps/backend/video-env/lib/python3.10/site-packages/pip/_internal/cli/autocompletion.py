"""Logic that powers autocompletion installed by ``pip completion``.
"""

import optparse
import os
import sys
from itertools import chain
from typing import Any, Iterable, List, Optional

from pip._internal.cli.main_parser import create_main_parser
from pip._internal.commands import commands_dict, create_command
from pip._internal.metadata import get_default_environment


def autocomplete() -> None:
    """Entry Point for completion of main and subcommand options."""
    if not should_complete():
        return

    cwords, cword, current = get_completion_data()
    parser = create_main_parser()
    subcommands = list(commands_dict)

    subcommand_name = get_subcommand_name(cwords, subcommands)
    if subcommand_name:
        handle_subcommand_completion(subcommand_name, cwords, cword, current)
    else:
        handle_main_completion(parser, cwords, cword, current, subcommands)


def should_complete() -> bool:
    """Check if autocompletion should proceed."""
    return (
        "PIP_AUTO_COMPLETE" in os.environ
        and os.environ.get("COMP_WORDS")
        and os.environ.get("COMP_CWORD")
    )


def get_completion_data() -> tuple:
    """Retrieve completion data from environment variables."""
    cwords = os.environ["COMP_WORDS"].split()[1:]
    cword = int(os.environ["COMP_CWORD"])
    try:
        current = cwords[cword - 1]
    except IndexError:
        current = ""
    return cwords, cword, current


def get_subcommand_name(cwords: List[str], subcommands: List[str]) -> Optional[str]:
    """Determine the subcommand name from the given words."""
    for word in cwords:
        if word in subcommands:
            return word
    return None


def handle_subcommand_completion(subcommand_name: str, cwords: List[str], cword: int, current: str) -> None:
    """Handle completion for subcommands."""
    if subcommand_name == "help":
        sys.exit(1)

    if should_list_installed_dists(subcommand_name, current):
        list_installed_dists(current, cwords)
    elif should_list_installables(subcommand_name, current):
        list_installables(current)
    else:
        complete_subcommand_options(subcommand_name, cwords, cword, current)


def should_list_installed_dists(subcommand_name: str, current: str) -> bool:
    """Check if installed distributions should be listed."""
    return not current.startswith("-") and subcommand_name in ["show", "uninstall"]


def list_installed_dists(current: str, cwords: List[str]) -> None:
    """List locally installed distributions."""
    env = get_default_environment()
    lc = current.lower()
    installed = [
        dist.canonical_name
        for dist in env.iter_installed_distributions(local_only=True)
        if dist.canonical_name.startswith(lc) and dist.canonical_name not in cwords[1:]
    ]
    if installed:
        for dist in installed:
            print(dist)
        sys.exit(1)


def should_list_installables(subcommand_name: str, current: str) -> bool:
    """Check if installable paths should be listed."""
    return not current.startswith("-") and subcommand_name == "install"


def list_installables(current: str) -> None:
    """List installable paths."""
    for path in auto_complete_paths(current, "path"):
        print(path)
    sys.exit(1)


def complete_subcommand_options(subcommand_name: str, cwords: List[str], cword: int, current: str) -> None:
    """Complete options for the given subcommand."""
    subcommand = create_command(subcommand_name)
    options = get_subcommand_options(subcommand)

    prev_opts = [x.split("=")[0] for x in cwords[1 : cword - 1]]
    options = [(x, v) for (x, v) in options if x not in prev_opts]
    options = [(k, v) for k, v in options if k.startswith(current)]

    completion_type = get_path_completion_type(cwords, cword, subcommand.parser.option_list_all)
    if completion_type:
        paths = auto_complete_paths(current, completion_type)
        options = [(path, 0) for path in paths]

    for option in options:
        opt_label = option[0]
        if option[1] and option[0].startswith("--"):
            opt_label += "="
        print(opt_label)


def get_subcommand_options(subcommand: Any) -> List[tuple]:
    """Retrieve options for the given subcommand."""
    options = []
    for opt in subcommand.parser.option_list_all:
        if opt.help != optparse.SUPPRESS_HELP:
            options += [(opt_str, opt.nargs) for opt_str in opt._long_opts + opt._short_opts]
    return options


def handle_main_completion(parser: Any, cwords: List[str], cword: int, current: str, subcommands: List[str]) -> None:
    """Handle completion for main parser options."""
    opts = [i.option_list for i in parser.option_groups]
    opts.append(parser.option_list)
    flattened_opts = chain.from_iterable(opts)

    if current.startswith("-"):
        for opt in flattened_opts:
            if opt.help != optparse.SUPPRESS_HELP:
                subcommands += opt._long_opts + opt._short_opts
    else:
        completion_type = get_path_completion_type(cwords, cword, flattened_opts)
        if completion_type:
            subcommands = list(auto_complete_paths(current, completion_type))

    print(" ".join([x for x in subcommands if x.startswith(current)]))
    sys.exit(1)


def get_path_completion_type(
    cwords: List[str], cword: int, opts: Iterable[Any]
) -> Optional[str]:
    """Get the type of path completion (``file``, ``dir``, ``path`` or None)

    :param cwords: same as the environmental variable ``COMP_WORDS``
    :param cword: same as the environmental variable ``COMP_CWORD``
    :param opts: The available options to check
    :return: path completion type (``file``, ``dir``, ``path`` or None)
    """
    if cword < 2 or not cwords[cword - 2].startswith("-"):
        return None
    for opt in opts:
        if opt.help == optparse.SUPPRESS_HELP:
            continue
        for o in str(opt).split("/"):
            if cwords[cword - 2].split("=")[0] == o:
                if not opt.metavar or any(x in ("path", "file", "dir") for x in opt.metavar.split("/")):
                    return opt.metavar
    return None


def auto_complete_paths(current: str, completion_type: str) -> Iterable[str]:
    """If ``completion_type`` is ``file`` or ``path``, list all regular files
    and directories starting with ``current``; otherwise only list directories
    starting with ``current``.

    :param current: The word to be completed
    :param completion_type: path completion type(``file``, ``path`` or ``dir``)
    :return: A generator of regular files and/or directories
    """
    directory, filename = os.path.split(current)
    current_path = os.path.abspath(directory)
    # Don't complete paths if they can't be accessed
    if not os.access(current_path, os.R_OK):
        return
    filename = os.path.normcase(filename)
    # list all files that start with ``filename``
    file_list = (
        x for x in os.listdir(current_path) if os.path.normcase(x).startswith(filename)
    )
    for f in file_list:
        opt = os.path.join(current_path, f)
        comp_file = os.path.normcase(os.path.join(directory, f))
        # complete regular files when there is not ``<dir>`` after option
        # complete directories when there is ``<file>``, ``<path>`` or
        # ``<dir>``after option
        if completion_type != "dir" and os.path.isfile(opt):
            yield comp_file
        elif os.path.isdir(opt):
            yield os.path.join(comp_file, "")
